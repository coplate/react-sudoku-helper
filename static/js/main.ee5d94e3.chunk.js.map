{"version":3,"sources":["Board.js","rules/region.js","rules/standard.js","Cage.js","rules/cage.js","Same.js","rules/same.js","Kropke.js","rules/kropke.js","rules/knight.js","rules/king.js","rules/pawn.js","Thermometer.js","rules/thermometer.js","Renban.js","rules/renban.js","Mod.js","rules/mod.js","Line.js","rules/littleKiller.js","Canvas.js","rules/whisper.js","rules/palindrome.js","rules/quadruple.js","App.js","reportWebVitals.js","index.js"],"names":["Given","props","squareData","given","className","Answer","answer","Snyder","candidate_count","candidates","filter","c","length","map","value","corner","style","onClick","snyderClickHandler","Square","selected","color","id","idx","row","column","onMouseMove","squareDragHandler","onMouseDown","Board","rules","rule","component","Array","keys","boardData","Region","cells","this","cellIndexes","ruleB","newBoardData","cloneSquare","mutableBoardData","Standard","ruleA","supportsIntersectionSource","mutated","fill","forEach","cm","index","arr","candidate","locationB","i","includes","intersection","every","console","log","cellIdx","immutableSquare","replacementCandidates","newSquareData","removeOther","known","otherMutations","a","mutations","array","cIndex","cArray","s","solved","some","cellIndex","y","x","height","width","cellData","Math","floor","inRectangle","gridClasses","Cage","border","cageVal","val","cell","types","push","type","join","p","parseInt","exact","digits","sum","otherCellIndexes","cageValidates","cageValue","cIdx","Same","same","Kropke","path","startColumn","startRow","endColumn","endRow","dx","dy","min","valueType","abs","gridColumn","gridRow","candidateArrayIndex","validCandidates","adjacentArrayIndexes","ci","valid","adjacentArrayIndex","kropkeValidates","Knight","matchDistance","comparedKnown","King","Pawn","Thermometer","bulb","minN","maxN","n","max","Renban","digit","otherDigits","slice","startingCellIndexes","renbanValidates","allowed","renLength","start","Mod","modVal","modResult","result","Tube","linetype","LittleKiller","Line","Canvas","children","Whisper","difference","forbidden","Set","size","Palindrome","opposingIndex","opposingCandidates","Quadruple","values","split","unknownCandidates","unsolvedCells","delete","localMutations","Controls","e","clickDispatcher","mode","prompt","startingState","k","cageFlags","columnRules","fromRectangle","rowRules","boxRules","b","App","useState","setMode","count","setCount","history","setHistory","current","applyNewRule","newRule","updateBoardHistory","command","selectedCells","selection","accept","chessPiece","parameter","v","q","keyPressHandler","event","target","readOnly","preventDefault","number","key","isNaN","updateSelections","useEffect","document","addEventListener","removeEventListener","lastAction","startsWith","rule_mutations","apply","indexA","arrayA","indexB","arrayB","applyRules","select","selectionType","clearFlag","action","eq","updateSelectionHistory","extractClonedSquare","spot","newSelections","selections","setFlags","selectedCellIndexes","acceptedCells","find","onKeyDown","name","getElementById","givens","answers","givenValues","answerValues","exportString","bind","clear","ctrlKey","buttons","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.ee5d94e3.chunk.js","sourcesContent":["\nfunction Given(props){\n    \n    if( props.squareData.given ){\n      // eslint-disable-next-line\n      \n      return (\n        <div className={`given numeric cell-child`} >\n          {props.squareData.given}\n        </div>\n    \n      )\n    \n    }\n    return null;\n  }\n\n  function Answer(props){\n    \n    if( props.squareData.answer ){\n      return (\n        <div className={`answer numeric  cell-child`} >\n          {props.squareData.answer}\n        </div>\n    \n      )\n    \n    }\n    return null;\n  }\n\n  \n  function Snyder(props){\n    let candidates = props.squareData.candidates;\n    let remaining_candidates = candidates.filter( (c) => c>0 );\n    let candidate_count = remaining_candidates.length; // used to tell if this is the last candidate in a region\n    // something else tells us if this is the only one of it's kind in a regions.\n    // or should the rule, when detecting 1, remove the others?\n    \n\n\n    return (\n      <div className={`snyder cell-child`} >\n        {\n          props.squareData.candidates.map( (value, corner) => {\n            let style = 'hide';\n            if(value>0){\n                style = 'show'\n                if( candidate_count === 1 ){\n                    style='highlight'\n                }\n            }\n            \n\n            return <div key={`corner-${corner}`} className={`corner corner-${corner} corner-style-${style} numeric`} onClick={props.snyderClickHandler(props, corner)}>{value}</div>\n          })\n        }\n      </div>\n  \n    )  \n    \n  }\n  \n  function Square(props){\n    let selected=(props.squareData.selected)?\"selected\":\"\";\n    let color = (props.squareData.color)?props.squareData.color:\"none\";\n    return (\n      <div id={`cell-${props.idx}`} className = {`cell cell-${props.idx} row-${props.row} column-${props.column} ${selected} cell-color-${color}`} onClick={props.onClick(props)} onMouseMove={props.squareDragHandler(props)}  onMouseDown={props.onMouseDown(props)}  >\n       <Given {...props} />\n       <Answer {...props} />\n       <Snyder {...props} />\n       \n       </div>\n    );\n  \n  }\n  \n  function Board(props){\n    return (\n      <div className=\"board-holder\">\n        <div className=\"Board\">\n          {\n            props.rules.map(rule => rule.component())\n          }\n          \n          <div className=\"cell-holder\">\n          {\n            [...Array(9).keys()].map( row => {\n              return [...Array(9).keys()].map( column => {\n                let idx = column + (9* row);\n                return <Square key={idx} {...props} row = {row} column={column} idx={idx} squareData={props.boardData[idx]}/>\n              })\n            })\n          }\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  /*\n          <Candidates {...props} />\n        <Snyder {...props} />\n        {\n        //<Notes {...props} />\n        }\n        <Answer {...props} />\n        <Given {...props} />\n\n        */\n  export default Board;","\n\nclass Region {\n    \n    constructor(cells) {\n        this.cellIndexes=cells.map(c => c.idx);\n    }\n\n    supportsIntersectionSource(){\n        return false;\n    }\n    applyIntersection(ruleB,newBoardData, cloneSquare){\n        return 0;\n    }\n    setFlags(newBoardData){\n        return 0;\n    }\n    // cloneSquare function allows us to create new square object to prevent mutating the old version\n    // pass a mutate function istead that will coder the clone and board updatge in the parent?\n    apply(mutableBoardData, cloneSquare){\n        \n\n      return 0;\n        \n    }\n    component(){\n        return <></>;\n    }\n\n}\nexport default Region;","\nimport Region from './region';\n\nclass Standard extends Region  {\n    static inRectangle(y,x,height,width, cellData){\n        let index = cellData.idx;\n        let row = Math.floor( index / 9);\n        let column = index % 9;\n        if( row >= y && row < y+height ){\n            if( column >= x && column < x+width ){\n                return true;\n            }\n        }\n        \n        return false;\n        \n    }\n    \n    static fromRectangle(y,x,height,width, boardData){\n        \n        let cells = boardData.filter( cellData =>{  \n            \n            return Standard.inRectangle(y,x,height,width, cellData);\n        });\n        return new Standard(cells);\n    }\n    \n    // constructor(cells) {\n    //     super(cells);\n    //     //this.cellIndexes=cells.map(c => c.idx);\n    // }\n        //supportsIntersectionSource is effectively - a 9 cell normal sudoku rule\n    supportsIntersectionSource(){\n        return true;\n    }\n    // if every instance of candidate in ruleB is in the intersection\n    // remove the candidate form all other locations of ruleA\n    applyIntersection(ruleB,newBoardData, cloneSquare){\n        let ruleA = this;\n        if( ruleA === ruleB ){\n            return 0;\n        }\n        if( ! ruleB.supportsIntersectionSource()){\n            return;\n        }\n        let mutated = 0;\n        [...Array(9).fill(0).keys()].forEach((cm, index, arr) => {\n          \n            // if all of the values of candidate are in (A int B), remove candidate from all other cells in B;\n            let candidate = index+1;\n            let locationB = ruleB.cellIndexes.filter( (i) => newBoardData[i].candidates.includes(candidate));\n            let intersection = ruleB.cellIndexes.filter( (i) => ruleA.cellIndexes.includes(i));\n            \n\n            if(locationB.every( (i) => intersection.includes(i) )){\n              // every value of candidate from ruleA is within the intersection.  for normal rules this means that the value must be removed form \n              // all cells in ruleB, if B is a 'unique' rule;\n              // but not all \n              console.log(\"We have found an itersection of \", candidate, locationB, intersection);\n              // remove candidate from all other locations in ruleB\n\n              this.cellIndexes.forEach( (cellIdx) => {\n                  if( intersection.includes(cellIdx) ){\n                      return;\n                  }\n                let immutableSquare = newBoardData[cellIdx];\n                let replacementCandidates = [...immutableSquare.candidates];\n                \n                let newSquareData = cloneSquare(immutableSquare);\n                mutated=1;\n                console.log(\"Removing candidate <C> from index <i>\", candidate, cellIdx)\n                newSquareData.candidates = replacementCandidates.map( (c) =>  c===candidate?0:c);\n                console.log(newSquareData.candidates);\n                newBoardData[cellIdx]=newSquareData;\n                });\n\n            }\n            \n        });\n\n        return mutated;\n    }\n   \n    // cloneSquare function allows us to create new square object to prevent mutating the old version\n    // pass a mutate function istead that will coder the clone and board updatge in the parent?\n    apply(mutableBoardData, cloneSquare){\n        // a Standard Region is Column, Row, Box or others where \"Normal Sudoku Rules Apply\"\n        // Additionally, any other 9 cell region can be called standard if they\n        // can and Must contain 1 and only 1 of each number 1-9\n        \n        // Or, should the \"Standard\" region contain all cells, and validate based on row, column and box in one function\n        // I will try that, calling it \"Normal\"\n\n        // this function will remove impossible candidates and return the new list\n    \n\n        let removeOther = (replacementCandidates, known) => {\n            let otherMutations = 0;\n            replacementCandidates.forEach( (c,i,a) =>{\n                if( c > 0 && c !== known ){\n                    a[i]=0;\n                    otherMutations = otherMutations+1;\n                }\n            });\n            return otherMutations;\n        }\n\n        //5..2...4....6.3....3...9..7..3..7.....7..8...6......2..8......3...4..6.....1..5..\n        let mutations = 0;\n        this.cellIndexes.forEach( (cellIdx, index, array) => {\n            let immutableSquare = mutableBoardData[cellIdx];\n            let replacementCandidates = [...immutableSquare.candidates];\n            let known = immutableSquare.given || immutableSquare.answer;\n        \n            // clear all other values if we know the answer\n            if(  known ){\n                mutations += removeOther(replacementCandidates, known);\n                // remove all candidate except given\n            }\n            \n\n            // if the region contains only 1 of a given candidate, remove all other candidates form that cell\n            replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n                if( candidate > 0 ){\n                    let regionSquares = this.cellIndexes.map( i=> mutableBoardData[i]);\n                    let regionCandidates = regionSquares.map( s => s.candidates );\n                    let matchingCandidateValues = regionCandidates.map( c => c[cIndex]).filter( c => c !== 0);\n\n                    if( matchingCandidateValues.length === 1 ){\n                        mutations += removeOther(cArray, candidate);\n                    }\n                }\n\n            });\n            // if the region has a known candidate in another cell, remove that from this cell\n            replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n\n                if( candidate > 0 ){\n\n                    if(this.solved(mutableBoardData, candidate, cellIdx)){\n                        \n                        replacementCandidates[cIndex] = 0;\n                        mutations = mutations+1;\n                    }\n\n                \n                }\n\n            });\n            // if the region has a candidate that exists in the intersection of two regions, \n            // and the candidate only exists in that intersection on the Other rule, \n            //then this candidate must also exist within said intersection on this rule!\n            if( mutations>0 ){\n                let newSquareData = cloneSquare(immutableSquare);\n                console.log(\"Removing value from square\");\n                newSquareData.candidates = replacementCandidates;\n                \n                mutableBoardData[cellIdx]=newSquareData;\n            }\n\n            \n            \n\n        });\n        return mutations;\n        \n        // somethign else runs after this, and puts error CSS on each thing\n\n\n\n\n        /*\n        validatedResults.forEach((result, resultIndex, resultArray) => {\n\n        let newSquareData = newBoardData[result.idx];\n        if(! selectedCellIndexes.includes(result.idx)){\n          // Not Already cloned from the value update\n          newSquareData = cloneSquareData(result.idx, );\n        }\n        newSquareData.candidates = [...result.candidates];\n        newBoardData[result.idx] = newSquareData;\n      });\n      */\n    }\n    // This will return error flags for each cell/index that has a conflict\n    validate(boardData){\n\n    }\n    solved( boardData, candidate, cellIdx ){\n        return this.cellIndexes.some( (cellIndex, index, array) => {\n            if( cellIdx !== cellIndex){\n                if( boardData[cellIndex].given === candidate){\n                    return true;\n                }\n                if( boardData[cellIndex].answer === candidate){\n                    return true;\n                }\n            }\n            return false;\n        });\n        \n        // if candidate is listed as Given or Answer for anything ELSE in the region, remove the candidate\n    }\n    \n\n}\nexport default Standard;","function Cage(props){\n    const cells = props.cells;\n    let border = [];\n    let cageVal = \"?\";\n    if( props.val){\n        cageVal = props.val;\n    }\n    cells.forEach((cell, i, a) => {\n        \n\n        let column = cell%9;\n        let row = (cell-column)/9;\n\n        let types=[];\n        if(! cells.includes(9*(row)+(column+1)) ){\n                types.push(\"cage-right\");\n        }\n        if(! cells.includes(9*(row+1)+(column)) ){\n                types.push(\"cage-down\");\n        }\n        if(! cells.includes(9*(row)+(column-1)) ){\n                types.push(\"cage-left\");\n        }\n        if(! cells.includes(9*(row-1)+(column)) ){\n                types.push(\"cage-up\");\n        }\n       \n        if( types ){\n            border.push({\"idx\":cell, type:types.join(\" \"), x:row, y:column });\n        }\n        //0,45,90,135,180, 225, 270, 315, 360\n        \n    });\n    return <div className=\"cage\">\n        <div className={`cage-val ${gridClasses(cells[0])}`}  >{cageVal}</div> \n        {\n        border.map( p => <div key={p.idx} className={`cage-cell ${p.type} ${gridClasses(p.idx)}`}  > \n      </div> \n        )}\n    </div>\n    \n}\nfunction gridClasses(idx){\n    let column = idx%9;\n    let row = (idx-column)/9;\n    return `row-${row} column-${column}`;\n}\n\nexport default Cage;\n","import Region from \"./region\";\nimport CageComponent from \"../Cage\";\n\nclass Cage extends Region{\n\n    constructor(cells, exact=true, value) {\n        super(cells);\n\n        \n        this.value = parseInt(value);\n        this.exact = this.value > 0;\n    }\n\n    cageValidates(mutableBoardData, digits, sum, cellIndexes){\n\n        if( cellIndexes.length === 0 && sum === 0 ){\n            return true;\n        }\n        if( sum < 1){\n            return false;\n        }\n        if( cellIndexes.length === 1 ){\n            if( digits.includes(sum) ){\n                return false;\n            }\n            return mutableBoardData[cellIndexes[0]].candidates.includes(sum);\n        }\n\n        return cellIndexes.some( index => {\n            let otherCellIndexes = cellIndexes.filter( i=> i!== index);\n            let candidates = mutableBoardData[index].candidates.filter( c => (c>0 && c < sum && !digits.includes(c)) );\n            \n            return candidates.some( candidate => {\n                if( this.cageValidates(mutableBoardData, [...digits, candidate], sum-candidate, otherCellIndexes) ){\n                    return true;\n                }\n                return false;\n            })\n\n        });\n        \n    }\n\n    component(){\n        return <CageComponent cells={[...this.cellIndexes]} val={this.value}/>;\n    }\n\n    setFlags(newBoardData){\n        if( this.exact ){\n            this.cellIndexes.forEach( cellIdx => {\n                let newSquareData = newBoardData[cellIdx].cloneSquare();\n                newSquareData.cageValue=this.value;\n                newBoardData[cellIdx]=newSquareData;\n            });\n            return 1;\n        }\n\n        return 0;\n    }\n    // cloneSquare function allows us to create new square object to prevent mutating the old version\n    // pass a mutate function istead that will coder the clone and board updatge in the parent?\n    apply(mutableBoardData, cloneSquare){\n        // in a classic cage, everythign is unique, and there is a sum;\n        \n\n\n\n        //5..2...4....6.3....3...9..7..3..7.....7..8...6......2..8......3...4..6.....1..5..\n        let mutations = 0;\n        this.cellIndexes.forEach( (cellIdx, index, array) => {\n            let immutableSquare = mutableBoardData[cellIdx];\n            let replacementCandidates = [...immutableSquare.candidates];\n            \n        \n         \n            // if the region contains only 1 of a given candidate, remove all other candidates form that cell -- only for 9 square unique Regions - not cages per se\n            // if the region has a known candidate in another cell, remove that from this cell - only for unique Regions\n            if( this.exact ){\n                replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n                    \n                    if( candidate > 0 ){\n                        let solvedIndex = this.cellIndexes.filter( (i) => i!==cellIdx).some( cIdx => (mutableBoardData[cIdx].given||mutableBoardData[cIdx].answer) === candidate  );\n                        if( solvedIndex){\n                            replacementCandidates[cIndex] = 0;\n                            mutations = mutations+1;\n                        }\n                    }\n                });\n\n                \n            }     \n\n                        \n               \n                // need to honor the unique flag\n              //also for exeact matches is: if a candidate is too big, or too small to work, remove it\n              if( this.exact ){\n                let otherCellIndexes = this.cellIndexes.filter( i=> i!== cellIdx);\n                replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n                    if( candidate > 0 ){\n                        if( ! this.cageValidates(mutableBoardData, [candidate], this.value-candidate, otherCellIndexes)){\n                            replacementCandidates[cIndex] = 0;\n                            mutations = mutations+1;\n                        }\n                        \n\n                    }\n                });\n\n                \n                \n            }\n\n            // if the region has a candidate that exists in the intersection of two regions, \n            // and the candidate only exists in that intersection on the Other rule, \n            //then this candidate must also exist within said intersection on this rule!\n\n\n            if( mutations>0 ){\n                let newSquareData = cloneSquare(immutableSquare);\n                console.log(\"Removing value from square\");\n                newSquareData.candidates = replacementCandidates;\n                \n                mutableBoardData[cellIdx]=newSquareData;\n            }\n\n            \n            \n\n        });\n        return mutations;\n        \n    }\n     \n\n\n}\nexport default Cage;","function Same(props){\n    const cells = props.cells;\n    return <div className=\"same\">\n        {\n            cells.map( cell => <div className={`same-cell ${gridClasses(cell)}`} /> )\n        }\n    </div>\n    \n}\nfunction gridClasses(idx){\n    let column = idx%9;\n    let row = (idx-column)/9;\n    return `row-${row} column-${column}`;\n}\n\nexport default Same;\n","import Region from \"./region\";\nimport SameComponent from \"../Same\";\n\nclass Same extends Region{\n\n    constructor(cells, exact=true, value) {\n        super(cells);\n    }\n\n    same(mutableBoardData, candidate, cellIndexes){\n        \n        return cellIndexes.every( index => {\n            let candidates = mutableBoardData[index].candidates;\n            return candidates.includes( candidate );\n\n        });\n        \n    }\n\n    component(){\n        return <SameComponent cells={[...this.cellIndexes]} />;\n    }\n\n   \n    // cloneSquare function allows us to create new square object to prevent mutating the old version\n    // pass a mutate function istead that will coder the clone and board updatge in the parent?\n    apply(mutableBoardData, cloneSquare){\n        // in a classic cage, everythign is unique, and there is a sum;\n        \n\n\n\n        //5..2...4....6.3....3...9..7..3..7.....7..8...6......2..8......3...4..6.....1..5..\n        let mutations = 0;\n        this.cellIndexes.forEach( (cellIdx, index, array) => {\n            let immutableSquare = mutableBoardData[cellIdx];\n            let replacementCandidates = [...immutableSquare.candidates];\n            \n            let otherCellIndexes = this.cellIndexes.filter( i=> i!== cellIdx);\n            replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n                //console.log(`Processing same for candidate ${candidate} in cell ${cellIdx}`)\n                if( candidate > 0 ){\n                    if( ! this.same(mutableBoardData, candidate, otherCellIndexes)){\n                        replacementCandidates[cIndex] = 0;\n                        mutations = mutations+1;\n                    }\n                    \n\n                }\n            });\n    \n            // if the region has a candidate that exists in the intersection of two regions, \n            // and the candidate only exists in that intersection on the Other rule, \n            //then this candidate must also exist within said intersection on this rule!\n\n\n            if( mutations>0 ){\n                let newSquareData = cloneSquare(immutableSquare);\n                console.log(\"Removing value from square\");\n                newSquareData.candidates = replacementCandidates;\n                \n                mutableBoardData[cellIdx]=newSquareData;\n            }\n\n            \n            \n\n        });\n        return mutations;\n        \n    }\n     \n\n\n}\nexport default Same;","function Kropke(props){\n    const cells = props.cells;\n\n    let path = [];\n    cells.forEach((cell, i, a) => {\n        \n        if( i > 0){\n\n            let startColumn = a[i-1]%9;\n            let startRow = (a[i-1]-startColumn)/9;\n            let endColumn = a[i]%9;\n            let endRow = (a[i]-endColumn)/9;\n\n            let dx = (startColumn-endColumn);\n            let dy = (startRow-endRow);\n            let x = Math.min(startColumn,endColumn);\n            let y = Math.min(startRow,endRow);\n            let type=\"dot\";\n            if( dx === 1 ){\n                type=type+\" dot-\"+props.valueType+\"-right\";\n                \n            }\n            if( dy ===1 ){\n                type=type+\" dot-\"+props.valueType+\"-down\";\n            }\n            if( dx === -1 ){\n                type=type+\" dot-\"+props.valueType+\"-left\";\n                \n            }\n            if( dy === -1 ){\n                type=type+\" dot-\"+props.valueType+\"-up\";\n            }\n            //0,45,90,135,180, 225, 270, 315, 360\n            path.push({\"idx\":cell, startColumn:x, startRow:y, dx:Math.abs(dx), dy:Math.abs(dy), type:type });\n        }\n    });\n    return <div className=\"kropke\">\n        {\n        \n        path.map( p => <div key={p.idx} className={`${p.type}`} style={{gridColumn: `${p.startColumn+1} / span ${p.dx+1}`, gridRow: `${p.startRow+1} / span ${p.dy+1}`}} > \n              \n\n      </div> \n        )}\n    </div>\n    \n}\n\n\nexport default Kropke;\n","import Region from \"./region\";\nimport KropkeComponent from \"../Kropke\";\n\nclass Kropke extends Region{\n\n    constructor(cells, value) {\n        super(cells);\n\n        this.value = parseInt(value);\n    }\n\n    kropkeValidates(mutableBoardData, cellIndexes, candidateArrayIndex, candidate){\n\n        if( cellIndexes.length === 0){\n            return true;\n        }\n        console.log(`Checking if Candidate ${candidate} is valid in square ${candidateArrayIndex}`);\n        let validCandidates = [];\n        if( this.value === 1 ){\n            validCandidates.push(candidate+1);\n            validCandidates.push(candidate-1);\n        }else{\n            validCandidates.push(candidate*2);\n            validCandidates.push(candidate/2);\n\n        }\n        console.log(`Valid Candidates are ${validCandidates} and cellIndexes.length is ${cellIndexes.length}`);\n    \n        // if( cellIndexes.length === 1 ){\n        //         let valid =  mutableBoardData[cellIndexes[0]].candidates.filter( c => (c!==0 && validCandidates.includes(c))).length > 0;\n        //         console.log(valid);\n        //         return valid;\n        // }\n        \n        let adjacentArrayIndexes = this.cellIndexes\n                                        .map( (ci, i ) => i)\n                                        .filter( i=> (i === candidateArrayIndex-1 || i === candidateArrayIndex+1))\n                                        .filter( i=> ( cellIndexes.includes(this.cellIndexes[i]) ));\n        \n        console.log(`Checking if Candidate ${candidate} is valid in square ${candidateArrayIndex}[${this.cellIndexes[candidateArrayIndex]}] - now checking Adjacent cells ${adjacentArrayIndexes}`);\n        \n        let valid = adjacentArrayIndexes.every( adjacentArrayIndex => {\n            console.log(\"Checking adjacentArrayIndex:\", adjacentArrayIndex);\n            console.log(\"Checking this.cellIndexes:\", this.cellIndexes);\n            let index = this.cellIndexes[adjacentArrayIndex];\n            console.log(\"Checking index:\", index);\n            let otherCellIndexes = cellIndexes.filter( i=> i!== index);\n            console.log(\"Checking otherCellIndexes:\", otherCellIndexes);\n            let candidates = mutableBoardData[index].candidates.filter( c => validCandidates.includes(c) );\n            return candidates.some( c => {\n                if( this.kropkeValidates(mutableBoardData, otherCellIndexes, adjacentArrayIndex, c) ){\n                    return true;\n                }\n                return false;\n            })\n            // validates\n        });\n        console.log(valid);\n        return valid;\n        \n    }\n\n    component(){\n        return <KropkeComponent cells={[...this.cellIndexes]} valueType={this.value} />;\n    }\n\n    setFlags(newBoardData){\n        // black/white\n        return 0;\n    }\n    // cloneSquare function allows us to create new square object to prevent mutating the old version\n    // pass a mutate function istead that will coder the clone and board updatge in the parent?\n    apply(mutableBoardData, cloneSquare){\n        // in a classic cage, everythign is unique, and there is a sum;\n        \n\n\n\n        //5..2...4....6.3....3...9..7..3..7.....7..8...6......2..8......3...4..6.....1..5..\n        let mutations = 0;\n        this.cellIndexes.forEach( (cellIdx, index, array) => {\n            let immutableSquare = mutableBoardData[cellIdx];\n            let replacementCandidates = [...immutableSquare.candidates];\n            \n           // kropke - adjacent cell must be either +-1 (white), or */2(black)\n           // Not just adjacent though, adjecent and seperated by kropke\n           // kropke set can be created as a string of pairs, to mark the connections, but for now assume single file.\n\n\n            let otherCellIndexes = this.cellIndexes.filter( i=> i!== cellIdx);\n            replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n                if( candidate > 0 ){\n\n                    if( ! this.kropkeValidates(mutableBoardData, otherCellIndexes, index, candidate) ){\n                        \n                        replacementCandidates[cIndex] = 0;\n                        mutations = mutations+1;\n                    }\n                }\n            });\n\n            // if the region has a candidate that exists in the intersection of two regions, \n            // and the candidate only exists in that intersection on the Other rule, \n            //then this candidate must also exist within said intersection on this rule!\n\n\n            if( mutations>0 ){\n                let newSquareData = cloneSquare(immutableSquare);\n                console.log(\"Removing value from square\");\n                newSquareData.candidates = replacementCandidates;\n                \n                mutableBoardData[cellIdx]=newSquareData;\n            }\n\n            \n            \n\n        });\n        return mutations;\n        \n    }\n     \n\n\n}\nexport default Kropke;","import Region from './region';\n\n//This is an example of a region that does not support intersection, because this is the whole thing\n// it cannot act as ruleB, but it can act as ruleA.\n// \nclass Knight extends Region{\n\n    constructor(cells, matchDistance=0) {\n        super(cells);\n        this.matchDistance = parseInt(matchDistance);\n    }\n\n    apply(mutableBoardData, cloneSquare){\n\n        //5..2...4....6.3....3...9..7..3..7.....7..8...6......2..8......3...4..6.....1..5..\n        let mutations = 0;\n        this.cellIndexes.forEach( (cellIdx, index, array) => {\n            let immutableSquare = mutableBoardData[cellIdx];\n            let replacementCandidates = [...immutableSquare.candidates];\n            \n            if( immutableSquare.given || immutableSquare.answer ){\n                return;  \n            };\n            \n        \n            let y = Math.floor(cellIdx/9);\n            let x = cellIdx % 9;\n    \n            replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n                \n                if( candidate > 0 ){\n                    let solvedIndex = this.cellIndexes.some( cIdx => {\n                        let comparedKnown = mutableBoardData[cIdx].given || mutableBoardData[cIdx].answer;\n                        if( comparedKnown !== 0){\n                            if( Math.abs( comparedKnown - candidate) === this.matchDistance ){\n                                if(  Math.abs( (Math.floor(cIdx/9)-y) * ((cIdx % 9)-x) )=== 2){\n                                    return true;\n                                }\n                            }\n                        }\n                        return false;\n                    });\n                    if( solvedIndex){\n                        console.log(\"Removing value from square\", cIndex, cellIdx);\n                        replacementCandidates[cIndex] = 0;\n                        mutations = mutations+1;\n                    }\n                }\n            });\n\n            // if the region has a candidate that exists in the intersection of two regions, \n            // and the candidate only exists in that intersection on the Other rule, \n            //then this candidate must also exist within said intersection on this rule!\n\n\n            if( mutations>0 ){\n                let newSquareData = cloneSquare(immutableSquare);\n                console.log(\"Removing value from square\");\n                newSquareData.candidates = replacementCandidates;\n                \n                mutableBoardData[cellIdx]=newSquareData;\n            }\n\n            \n            \n\n        });\n        return mutations;\n        \n    }\n     \n\n\n}\nexport default Knight;","import Region from './region';\n\n//This is an example of a region that does not support intersection, because this is the whole thing\n// it cannot act as ruleB, but it can act as ruleA.\n// \nclass King extends Region{\n\n    constructor(cells, matchDistance=0) {\n        super(cells);\n        this.matchDistance = parseInt(matchDistance);\n    }\n\n    apply(mutableBoardData, cloneSquare){\n\n        //5..2...4....6.3....3...9..7..3..7.....7..8...6......2..8......3...4..6.....1..5..\n        let mutations = 0;\n        this.cellIndexes.forEach( (cellIdx, index, array) => {\n            let immutableSquare = mutableBoardData[cellIdx];\n            let replacementCandidates = [...immutableSquare.candidates];\n            \n            if( immutableSquare.given || immutableSquare.answer ){\n                return;  \n            };\n            \n        \n            let y = Math.floor(cellIdx/9);\n            let x = cellIdx % 9;\n    \n            replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n                \n                if( candidate > 0 ){\n                    let solvedIndex = this.cellIndexes.some( cIdx => {\n                        let comparedKnown = mutableBoardData[cIdx].given || mutableBoardData[cIdx].answer;\n                        if( comparedKnown !== 0){\n                            if( Math.abs( comparedKnown - candidate) === this.matchDistance ){\n\n\n                                // 1 up, 0 over, 1 up, 1 over, 0 up, 1 over, etc\n                                // 1 up 0 over, 0 up 1 over // AKA pawn\n                                if(  Math.abs( (Math.floor(cIdx/9)-y) ) + Math.abs(  ((cIdx % 9)-x) ) === 1){\n\n                                    return true;\n                                }\n                                // 1 up 1 over // AKA the rest of king\n                                if(  Math.abs( (Math.floor(cIdx/9)-y) * ((cIdx % 9)-x) )=== 1){\n                                    return true;\n                                }\n                            }\n                        }\n                        return false;\n                    });\n                    if( solvedIndex){\n                        console.log(\"Removing value from square\", cIndex, cellIdx);\n                        replacementCandidates[cIndex] = 0;\n                        mutations = mutations+1;\n                    }\n                }\n            });\n\n            // if the region has a candidate that exists in the intersection of two regions, \n            // and the candidate only exists in that intersection on the Other rule, \n            //then this candidate must also exist within said intersection on this rule!\n\n\n            if( mutations>0 ){\n                let newSquareData = cloneSquare(immutableSquare);\n                console.log(\"Removing value from square\");\n                newSquareData.candidates = replacementCandidates;\n                \n                mutableBoardData[cellIdx]=newSquareData;\n            }\n\n            \n            \n\n        });\n        return mutations;\n        \n    }\n     \n\n\n}\nexport default King;","import Region from './region';\n\n//This is an example of a region that does not support intersection, because this is the whole thing\n// it cannot act as ruleB, but it can act as ruleA.\n// \nclass Pawn extends Region{\n\n    constructor(cells, matchDistance=0) {\n        super(cells);\n        this.matchDistance = parseInt(matchDistance);\n    }\n\n    apply(mutableBoardData, cloneSquare){\n\n        //5..2...4....6.3....3...9..7..3..7.....7..8...6......2..8......3...4..6.....1..5..\n        let mutations = 0;\n        this.cellIndexes.forEach( (cellIdx, index, array) => {\n            let immutableSquare = mutableBoardData[cellIdx];\n            let replacementCandidates = [...immutableSquare.candidates];\n            \n            if( immutableSquare.given || immutableSquare.answer ){\n                return;  \n            };\n            \n        \n            let y = Math.floor(cellIdx/9);\n            let x = cellIdx % 9;\n    \n            replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n                \n                if( candidate > 0 ){\n                    let solvedIndex = this.cellIndexes.some( cIdx => {\n                        let comparedKnown = mutableBoardData[cIdx].given || mutableBoardData[cIdx].answer;\n                        if( comparedKnown !== 0){\n                            if( Math.abs( comparedKnown - candidate) === this.matchDistance ){\n                                // 0 up, 1 over, or 1 up, zero over, nope, thats the pan restriction\n                                if(  Math.abs( Math.floor(cIdx/9)-y) + Math.abs((cIdx % 9)-x) === 1){\n                                    return true;\n                                }\n                            }\n                        }\n                        return false;\n                    });\n                    if( solvedIndex){\n                        console.log(\"Removing value from square\", cIndex, cellIdx);\n                        replacementCandidates[cIndex] = 0;\n                        mutations = mutations+1;\n                    }\n                }\n            });\n\n            // if the region has a candidate that exists in the intersection of two regions, \n            // and the candidate only exists in that intersection on the Other rule, \n            //then this candidate must also exist within said intersection on this rule!\n\n\n            if( mutations>0 ){\n                let newSquareData = cloneSquare(immutableSquare);\n                console.log(\"Removing value from square\");\n                newSquareData.candidates = replacementCandidates;\n                \n                mutableBoardData[cellIdx]=newSquareData;\n            }\n\n            \n            \n\n        });\n        return mutations;\n        \n    }\n     \n\n\n}\nexport default Pawn;","function Thermometer(props){\n    const cells = props.cells;\n    const bulb = cells[0];\n    let path = [];\n    cells.forEach((cell, i, a) => {\n        \n        if( i > 0){\n\n            let startColumn = a[i-1]%9;\n            let startRow = (a[i-1]-startColumn)/9;\n            let endColumn = a[i]%9;\n            let endRow = (a[i]-endColumn)/9;\n\n            let dx = (startColumn-endColumn);\n            let dy = (startRow-endRow);\n            let x = Math.min(startColumn,endColumn);\n            let y = Math.min(startRow,endRow);\n            let type=\"tube\";\n            if( dx === 1 ){\n                type=type+\" tube-right\";\n                \n            }\n            if( dy ===1 ){\n                type=type+\" tube-down\";\n            }\n            if( dx === -1 ){\n                type=type+\" tube-left\";\n                \n            }\n            if( dy === -1 ){\n                type=type+\" tube-up\";\n            }\n            //0,45,90,135,180, 225, 270, 315, 360\n            path.push({\"idx\":cell, startColumn:x, startRow:y, dx:Math.abs(dx), dy:Math.abs(dy), type:type });\n        }\n    });\n    return <div className=\"thermometer\">\n        <div className={`bulb ${gridClasses(bulb)}`} >\n        </div>\n        {\n        \n        path.map( p => <div key={p.idx} className={`${p.type}`} style={{gridColumn: `${p.startColumn+1} / span ${p.dx+1}`, gridRow: `${p.startRow+1} / span ${p.dy+1}`}} > \n              \n\n      </div> \n        )}\n    </div>\n    \n}\nfunction gridClasses(idx){\n    let column = idx%9;\n    let row = (idx-column)/9;\n    return `row-${row} column-${column}`;\n}\n\nexport default Thermometer;\n","import Region from \"./region\";\nimport ThemoComponent from \"../Thermometer\";\n\nclass Thermometer extends Region{\n\n\n    constructor(cells, exact=true, value=12) {\n        super(cells);\n        console.log(this.cellIndexes);\n\n        this.exact = exact;\n        this.value = parseInt(value);\n    }\n\n    component(){\n        return <ThemoComponent cells={[...this.cellIndexes]} />;\n    }\n  \n    // cloneSquare function allows us to create new square object to prevent mutating the old version\n    // pass a mutate function istead that will coder the clone and board updatge in the parent?\n    apply(mutableBoardData, cloneSquare){\n        // in a classic cage, everythign is unique, and there is a sum;\n        \n\n\n\n        //5..2...4....6.3....3...9..7..3..7.....7..8...6......2..8......3...4..6.....1..5..\n        let mutations = 0;\n        this.cellIndexes.forEach( (cellIdx, index, array) => {\n            let immutableSquare = mutableBoardData[cellIdx];\n            let replacementCandidates = [...immutableSquare.candidates];\n            \n//            let known = immutableSquare.given || immutableSquare.answer;\n        \n            \n                        \n            \n            //if a candidate is too big, or too small to work, remove it\n            replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n                if( candidate > 0 ){\n                    // a thermometer, square N must be bigger than square n-1, and smaller than square N+1\n//                    let forbidden = false;\n                    let minN = 0;\n                    let maxN = 10;\n                    if( index > 0 ){\n                        minN = Math.min( ...mutableBoardData[array[index-1]].candidates.filter( n => n>0)) ;\n                        // must be bigger than cellIdx-1\n                    }\n                    if( index < array.length-1 ){\n                        maxN = Math.max( ...mutableBoardData[array[index+1]].candidates.filter( n => n>0));\n                        // must be smaller than cellIdx+1\n                    }\n                    if( candidate >=maxN || candidate <= minN ){\n                        console.log(\"Removing value from square\", cIndex, cellIdx);\n                        replacementCandidates[cIndex] = 0;\n                        mutations = mutations+1;\n                    }\n                    \n\n                }\n            });\n\n                \n                \n            \n\n            // if the region has a candidate that exists in the intersection of two regions, \n            // and the candidate only exists in that intersection on the Other rule, \n            //then this candidate must also exist within said intersection on this rule!\n\n\n            if( mutations>0 ){\n                let newSquareData = cloneSquare(immutableSquare);\n                console.log(\"Removing value from square\");\n                newSquareData.candidates = replacementCandidates;\n                \n                mutableBoardData[cellIdx]=newSquareData;\n            }\n\n            \n            \n\n        });\n        return mutations;\n        \n    }\n     \n\n\n}\nexport default Thermometer;","function Renban(props){\n    const cells = props.cells;\n\n    let path = [];\n    cells.forEach((cell, i, a) => {\n        \n        if( i > 0){\n\n            let startColumn = a[i-1]%9;\n            let startRow = (a[i-1]-startColumn)/9;\n            let endColumn = a[i]%9;\n            let endRow = (a[i]-endColumn)/9;\n\n            let dx = (startColumn-endColumn);\n            let dy = (startRow-endRow);\n            let x = Math.min(startColumn,endColumn);\n            let y = Math.min(startRow,endRow);\n            let type=\"tube\";\n            if( dx === 1 ){\n                type=type+\" tube-right\";\n                \n            }\n            if( dy ===1 ){\n                type=type+\" tube-down\";\n            }\n            if( dx === -1 ){\n                type=type+\" tube-left\";\n                \n            }\n            if( dy === -1 ){\n                type=type+\" tube-up\";\n            }\n            //0,45,90,135,180, 225, 270, 315, 360\n            path.push({\"idx\":cell, startColumn:x, startRow:y, dx:Math.abs(dx), dy:Math.abs(dy), type:type });\n        }\n    });\n    return <div className=\"renban\">\n        {\n        \n        path.map( p => <div key={p.idx} className={`${p.type}`} style={{gridColumn: `${p.startColumn+1} / span ${p.dx+1}`, gridRow: `${p.startRow+1} / span ${p.dy+1}`}} > \n              \n\n      </div> \n        )}\n    </div>\n    \n}\n\n\nexport default Renban;\n","import Region from \"./region\";\nimport RenbanComponent from \"../Renban\";\n\nclass Renban extends Region{\n\n\n    constructor(cells, exact=true, value=12) {\n        super(cells);\n        //console.log(this.cellIndexes);\n\n        this.exact = exact;\n        this.value = parseInt(value);\n    }\n\n\n    renbanValidates(mutableBoardData, digits, cellIndexes){\n\n        if( digits.length === 0 ){\n            return true;\n        }\n\n        let digit = digits[0];\n        let otherDigits = digits.slice(1);\n\n        //console.log(\"Checking for digits in cells\", digits, cellIndexes);\n        let startingCellIndexes = cellIndexes.filter( i => mutableBoardData[i].candidates.includes(digit));\n\n        if( startingCellIndexes.length === 0){\n            //console.log(`No cells fulfil the requirement that digit ${digit} exists`);\n            return false;\n        }\n\n        return startingCellIndexes.some( (index) => this.renbanValidates(mutableBoardData, otherDigits, cellIndexes.filter( i => i!==index )) );;\n    }\n    component(){\n        return <RenbanComponent cells={[...this.cellIndexes]} />;\n    }\n  \n    // cloneSquare function allows us to create new square object to prevent mutating the old version\n    // pass a mutate function istead that will coder the clone and board updatge in the parent?\n    apply(mutableBoardData, cloneSquare){\n        // in a classic cage, everythign is unique, and there is a sum;\n        \n\n\n\n        //5..2...4....6.3....3...9..7..3..7.....7..8...6......2..8......3...4..6.....1..5..\n        let mutations = 0;\n        this.cellIndexes.forEach( (cellIdx, index, array) => {\n            let immutableSquare = mutableBoardData[cellIdx];\n            let replacementCandidates = [...immutableSquare.candidates];\n            \n//            let known = immutableSquare.given || immutableSquare.answer;\n        \n            \n                        \n            \n            //if a candidate is too big, or too small to work, remove it\n            replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n                if( candidate > 0 ){\n                    \n                    let allowed=false;\n                    let renLength = this.cellIndexes.length;\n                    for( var start = candidate; start > 0 && start > candidate-renLength; start-- ){\n                        let digits=[];\n                        for( var i = 0; i < renLength; i++){\n                            digits.push(start+i);\n                        }\n                        //console.log(\"Checking: \", digits, this.cellIndexes);\n\n                        allowed = this.renbanValidates(mutableBoardData, digits.filter( c => c!== candidate), this.cellIndexes.filter( i => i!== cellIdx))\n                        if( allowed){ break;}\n                    }\n\n                   \n\n                    if( !allowed ){\n                        //console.log(\"Removing value from square\", cIndex, cellIdx);\n                        replacementCandidates[cIndex] = 0;\n                        mutations = mutations+1;\n                    }\n                    \n\n                }\n            });\n\n                \n                \n            \n\n            // if the region has a candidate that exists in the intersection of two regions, \n            // and the candidate only exists in that intersection on the Other rule, \n            //then this candidate must also exist within said intersection on this rule!\n\n\n            if( mutations>0 ){\n                let newSquareData = cloneSquare(immutableSquare);\n                console.log(\"Removing value from square\");\n                newSquareData.candidates = replacementCandidates;\n                \n                mutableBoardData[cellIdx]=newSquareData;\n            }\n\n            \n            \n\n        });\n        return mutations;\n        \n    }\n     \n\n\n}\nexport default Renban;","function Mod(props){\n    const cells = props.cells;\n    let path = [];\n    cells.forEach((cell, i, a) => {\n    \n    \n        let startColumn = a[i-1]%9;\n        let startRow = (a[i-1]-startColumn)/9;\n        let endColumn = a[i]%9;\n        let endRow = (a[i]-endColumn)/9;\n\n        let dx = (startColumn-endColumn);\n        let dy = (startRow-endRow);\n        let x = Math.min(startColumn,endColumn);\n        let y = Math.min(startRow,endRow);\n        let type=\"tube\";\n        if( dx === 1 ){\n            type=type+\" tube-right\";\n            \n        }\n        if( dy ===1 ){\n            type=type+\" tube-down\";\n        }\n        if( dx === -1 ){\n            type=type+\" tube-left\";\n            \n        }\n        if( dy === -1 ){\n            type=type+\" tube-up\";\n        }\n        //0,45,90,135,180, 225, 270, 315, 360\n        path.push({\"idx\":cell, startColumn:x, startRow:y, dx:Math.abs(dx), dy:Math.abs(dy), type:type });\n    \n    });\n    return <div className=\"mod\">\n        {\n            cells.map( cell => <div className={`mod-${props.modVal}-${props.modResult} ${gridClasses(cell)}`} /> )\n        }\n    </div>\n    \n}\nfunction gridClasses(idx){\n    let column = idx%9;\n    let row = (idx-column)/9;\n    return `row-${row} column-${column}`;\n}\n\nexport default Mod;\n","import Region from \"./region\";\nimport ModComponent from \"../Mod\";\n\nclass Mod extends Region{\n\n    constructor(cells, modVal, result) {\n        super(cells);\n\n        this.value = parseInt(modVal);\n        this.result = parseInt(result);\n    }\n\n    \n    component(){\n        return <ModComponent cells={[...this.cellIndexes]} modVal={this.value} modResult={this.result}/>;\n    }\n\n    // cloneSquare function allows us to create new square object to prevent mutating the old version\n    // pass a mutate function istead that will coder the clone and board updatge in the parent?\n    apply(mutableBoardData, cloneSquare){\n        // in a classic cage, everythign is unique, and there is a sum;\n        \n\n\n\n        //5..2...4....6.3....3...9..7..3..7.....7..8...6......2..8......3...4..6.....1..5..\n        let mutations = 0;\n        this.cellIndexes.forEach( (cellIdx, index, array) => {\n            let immutableSquare = mutableBoardData[cellIdx];\n            let replacementCandidates = [...immutableSquare.candidates];\n            \n           \n\n                        \n            replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n                if( candidate > 0 ){\n                    if( candidate%this.value !== this.result ){\n                        replacementCandidates[cIndex] = 0;\n                        mutations = mutations+1;\n                    }              \n                }\n            });\n\n            // if the region has a candidate that exists in the intersection of two regions, \n            // and the candidate only exists in that intersection on the Other rule, \n            //then this candidate must also exist within said intersection on this rule!\n\n\n            if( mutations>0 ){\n                let newSquareData = cloneSquare(immutableSquare);\n                newSquareData.candidates = replacementCandidates;\n                mutableBoardData[cellIdx]=newSquareData;\n            }\n\n            \n            \n\n        });\n        return mutations;\n        \n    }\n     \n\n\n}\nexport default Mod;","function Tube(props){\n    const cells = props.cells;\n    const linetype = props.type || 'tube';\n    const val = props.val;\n    let path = [];\n    cells.forEach((cell, i, a) => {\n        \n        if( i > 0){\n\n            let startColumn = a[i-1]%9;\n            let startRow = (a[i-1]-startColumn)/9;\n            let endColumn = a[i]%9;\n            let endRow = (a[i]-endColumn)/9;\n\n            let dx = (startColumn-endColumn);\n            let dy = (startRow-endRow);\n            let x = Math.min(startColumn,endColumn);\n            let y = Math.min(startRow,endRow);\n            let type=\"tube\";\n            if( dx === 1 ){\n                type=type+` ${linetype}-right`;\n                \n            }\n            if( dy ===1 ){\n                type=type+` ${linetype}-down`;\n            }\n            if( dx === -1 ){\n                type=type+` ${linetype}-left`;\n                \n            }\n            if( dy === -1 ){\n                type=type+` ${linetype}-up`;\n            }\n            //0,45,90,135,180, 225, 270, 315, 360\n            path.push({\"idx\":cell, startColumn:x, startRow:y, dx:Math.abs(dx), dy:Math.abs(dy), type:type });\n        }\n    });\n    \n    return <div className=\"line\">\n        \n        {   val &&\n            <div className={`cage-val ${gridClasses(cells[0])}`}  >{val}</div> \n            \n        }\n        {\n            path.map( p => <div key={p.idx} className={`${p.type}`} style={{gridColumn: `${p.startColumn+1} / span ${p.dx+1}`, gridRow: `${p.startRow+1} / span ${p.dy+1}`}} />)}\n    </div>\n    \n}\n\nfunction gridClasses(idx){\n    let column = idx%9;\n    let row = (idx-column)/9;\n    return `row-${row} column-${column}`;\n}\nexport default Tube;\n","import Region from \"./region\";\nimport Line from \"../Line\";\n\nclass LittleKiller extends Region{\n\n    constructor(cells, exact=true, value) {\n        super(cells);\n        console.log(\"new little\")\n\n        this.exact = exact;\n        this.value = parseInt(value);\n    }\n\n    cageValidates(mutableBoardData, sum, cellIndexes){\n\n        if( cellIndexes.length === 0 && sum === 0 ){\n            return true;\n        }\n        if( sum < 1){\n            return false;\n        }\n        if( cellIndexes.length === 1 ){\n            \n            return mutableBoardData[cellIndexes[0]].candidates.includes(sum);\n        }\n\n        return cellIndexes.some( index => {\n            let otherCellIndexes = cellIndexes.filter( i=> i!== index);\n            let candidates = mutableBoardData[index].candidates.filter( c => (c>0 && c < sum ) );\n            \n            return candidates.some( candidate => {\n                if( this.cageValidates(mutableBoardData, sum-candidate, otherCellIndexes) ){\n                    return true;\n                }\n                return false;\n            })\n\n        });\n        \n    }\n\n    // probably change to line\n    component(){\n        return <Line cells={[...this.cellIndexes]} val={this.value}/>;\n    }\n\n\n    setFlags(newBoardData){\n        if( this.exact ){\n            this.cellIndexes.forEach( cellIdx => {\n                let newSquareData = newBoardData[cellIdx].cloneSquare();\n                newSquareData.cageValue=this.value;\n                newBoardData[cellIdx]=newSquareData;\n            });\n            return 1;\n        }\n\n        return 0;\n    }\n    // cloneSquare function allows us to create new square object to prevent mutating the old version\n    // pass a mutate function istead that will coder the clone and board updatge in the parent?\n    apply(mutableBoardData, cloneSquare){\n        //5..2...4....6.3....3...9..7..3..7.....7..8...6......2..8......3...4..6.....1..5..\n        let mutations = 0;\n        this.cellIndexes.forEach( (cellIdx, index, array) => {\n            let immutableSquare = mutableBoardData[cellIdx];\n            let replacementCandidates = [...immutableSquare.candidates];\n            \n        \n            // unlike cage, littleKiller can have repeats in other boxes.\n\n            \n            let otherCellIndexes = this.cellIndexes.filter( i=> i!== cellIdx);\n            replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n                if( candidate > 0 ){\n                    if( ! this.cageValidates(mutableBoardData, this.value-candidate, otherCellIndexes)){\n                        replacementCandidates[cIndex] = 0;\n                        mutations = mutations+1;\n                    }\n                    \n\n                }\n            });\n                \n\n                \n                \n           \n\n            // if the region has a candidate that exists in the intersection of two regions, \n            // and the candidate only exists in that intersection on the Other rule, \n            //then this candidate must also exist within said intersection on this rule!\n\n\n            if( mutations>0 ){\n                let newSquareData = cloneSquare(immutableSquare);\n                console.log(\"Removing value from square\");\n                newSquareData.candidates = replacementCandidates;\n                \n                mutableBoardData[cellIdx]=newSquareData;\n            }\n\n            \n            \n\n        });\n        return mutations;\n        \n    }\n     \n\n\n}\nexport default LittleKiller;","  // probably make this part of board, since they scale to 0 if I dont populate them\n  function Canvas(props){\n    return (\n      <div className=\"aaa\">\n         \n        {props.children}\n      </div>\n    );\n  }\n\n  export default Canvas;","import Region from \"./region\";\nimport Tube from \"../Line\";\n\nclass Whisper extends Region{\n\n\n    constructor(cells, difference=5) {\n        super(cells);\n        console.log(this.cellIndexes);\n\n        this.difference = difference;\n    }\n\n    component(){\n        return <Tube type=\"line\" cells={[...this.cellIndexes]} />;\n    }\n  \n    // cloneSquare function allows us to create new square object to prevent mutating the old version\n    // pass a mutate function istead that will coder the clone and board updatge in the parent?\n    apply(mutableBoardData, cloneSquare){\n\n        let mutations = 0;\n         this.cellIndexes.forEach( (cellIdx, index, array) => {\n             let immutableSquare = mutableBoardData[cellIdx];\n             let replacementCandidates = [...immutableSquare.candidates];\n             \n//             let known = immutableSquare.given || immutableSquare.answer;\n         \n             \n                         \n             \n             //if a candidate is too big, or too small to work, remove it\n             \n             replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n                 if( candidate > 0 ){\n                     // in a whisper candidate must be N greater or smaller than adjacent cell\n                     let forbidden = false;\n\n                     \n                     if( index > 0 ){\n                         let filteredPrev = new Set( [...mutableBoardData[array[index-1]].candidates.filter( n => n>0).filter( n => Math.abs(n - candidate) >= this.difference) ] );\n                         if( filteredPrev.size === 0){\n                             forbidden = true;\n                         }\n                         // must be bigger than cellIdx-1\n                     }\n                     if( index < array.length-1 ){\n                         \n                         let filteredNext = new Set([...mutableBoardData[array[index+1]].candidates.filter( n => n>0).filter( n => Math.abs(n - candidate) >= this.difference) ]);\n                         if( filteredNext.size === 0){\n                             forbidden = true;\n                         }\n                         // must be smaller than cellIdx+1\n                     }\n                     if( forbidden ){\n                         replacementCandidates[cIndex] = 0;\n                         mutations = mutations+1;\n                     }\n                     \n \n                 }\n             });\n \n                 \n                 \n             \n \n             // if the region has a candidate that exists in the intersection of two regions, \n             // and the candidate only exists in that intersection on the Other rule, \n             //then this candidate must also exist within said intersection on this rule!\n \n \n             if( mutations>0 ){\n                 let newSquareData = cloneSquare(immutableSquare);\n                 newSquareData.candidates = replacementCandidates;\n                 \n                 mutableBoardData[cellIdx]=newSquareData;\n             }\n \n             \n             \n \n         });\n         return mutations;\n        \n    }\n     \n\n\n}\nexport default Whisper;","import Region from \"./region\";\nimport Tube from \"../Line\";\n\nclass Palindrome extends Region{\n\n\n    // constructor(cells) {\n    //     super(cells);\n    // }\n\n    component(){\n        return <Tube cells={[...this.cellIndexes]} />;\n    }\n  \n    // cloneSquare function allows us to create new square object to prevent mutating the old version\n    // pass a mutate function istead that will coder the clone and board updatge in the parent?\n    apply(mutableBoardData, cloneSquare){\n\n        let mutations = 0;\n         this.cellIndexes.forEach( (cellIdx, index, array) => {\n             let immutableSquare = mutableBoardData[cellIdx];\n             let replacementCandidates = [...immutableSquare.candidates];\n             \n//             let known = immutableSquare.given || immutableSquare.answer;\n         \n             let opposingIndex = array.length - (index +1)\n             let opposingSquare = mutableBoardData[array[opposingIndex]];\n             let opposingCandidates = opposingSquare.candidates;    \n             \n             //if a candidate is too big, or too small to work, remove it\n             \n             replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n                 if( candidate > 0 ){\n                     \n                     let forbidden = true;\n\n                     if( opposingCandidates.includes(candidate)){\n                         forbidden=false;\n                     }\n                     if( forbidden ){\n                         replacementCandidates[cIndex] = 0;\n                         mutations = mutations+1;\n                     }\n                     \n \n                 }\n             });\n \n                 \n                 \n             \n \n             // if the region has a candidate that exists in the intersection of two regions, \n             // and the candidate only exists in that intersection on the Other rule, \n             //then this candidate must also exist within said intersection on this rule!\n \n \n             if( mutations>0 ){\n                 let newSquareData = cloneSquare(immutableSquare);\n                 newSquareData.candidates = replacementCandidates;\n                 \n                 mutableBoardData[cellIdx]=newSquareData;\n             }\n \n             \n             \n \n         });\n         return mutations;\n        \n    }\n     \n\n\n}\nexport default Palindrome;","import Region from \"./region\";\n\nclass Quadruple extends Region{\n\n\n    constructor(cells, values=[]) {\n        super(cells);\n        console.log(this.cellIndexes);\n\n        this.values = [...values.split('')].map(a => parseInt(a));\n        console.log(this.values);\n\n    }\n\n    component(){\n        return <div className=\"quad\">\n            <div className={\"quadcell \"+gridClasses(Math.min( ...this.cellIndexes ))} >\n                {this.values.join(\"\")}\n            </div>\n        </div>\n    }\n    removeOther (replacementCandidates, allowed)  {\n        let otherMutations = 0;\n        replacementCandidates.forEach( (c,i,a) =>{\n            if( ! allowed.includes(c) ){\n                if( a[i] !== 0){\n                    a[i]=0;\n                    otherMutations = otherMutations+1;\n                }\n            }\n        });\n        return otherMutations;\n    }  \n  \n    // cloneSquare function allows us to create new square object to prevent mutating the old version\n    // pass a mutate function istead that will coder the clone and board updatge in the parent?\n    apply(mutableBoardData, cloneSquare){\n        // every entry in the valus must be in one of the cells, any order\n\n        // so for a given candidate, if setting this candidate would make the rule impossible, then we must disable it\n\n        // there can be 1,2,3,4 elements\n\n        \n\n        \n       let unknownCandidates = new Set( [...this.values] );\n       let unsolvedCells = new Set( [ ...this.cellIndexes]);\n        this.cellIndexes.forEach( (cellIdx, index, array) => {\n            let immutableSquare = mutableBoardData[cellIdx];\n            \n            let known = immutableSquare.given || immutableSquare.answer;\n            unknownCandidates.delete(known);\n            if( known ){\n                unsolvedCells.delete(cellIdx);\n            }\n        });\n\n\n        let mutations = 0;\n        this.cellIndexes.forEach( (cellIdx, index, array) => {\n            let localMutations=0;\n            let immutableSquare = mutableBoardData[cellIdx];\n            let replacementCandidates = [...immutableSquare.candidates];\n            \n            let known = immutableSquare.given || immutableSquare.answer;\n            \n\n\n             // if the region contains only 1 of a given candidate, remove all other candidates form that cell\n             replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n                if( candidate > 0 ){\n                    if( this.values.includes(candidate) ){\n                        let regionSquares = this.cellIndexes.map( i=> mutableBoardData[i]);\n                        let regionCandidates = regionSquares.map( s => s.candidates );\n                        let matchingCandidateValues = regionCandidates.map( c => c[cIndex]).filter( c => c !== 0);\n\n                        if( matchingCandidateValues.length === 1 ){\n                            localMutations += this.removeOther(replacementCandidates, [candidate]);\n                            console.log(localMutations);\n                        }\n                    }\n                }\n\n            });\n                \n            if( !known ){\n                // If there are N options, and N squares, remove all other options\n                replacementCandidates.forEach( (candidate, cIndex, cArray) => {\n                    if( candidate > 0 ){\n                        // lets say I have 4 squares, and values 1,2,3,4\n                        if( ! this.values.includes(candidate) ){\n                            \n                            if(  unsolvedCells.size === unknownCandidates.size ){\n                                replacementCandidates[cIndex] = 0;\n                                localMutations +=1;\n                                console.log(\"Removing value from square\");\n                                console.log(\"Because\", candidate, unsolvedCells, unknownCandidates);\n                                \n\n                            }\n                        }\n                    }\n                });\n                \n         }\n\n            // if the region has a candidate that exists in the intersection of two regions, \n            // and the candidate only exists in that intersection on the Other rule, \n            //then this candidate must also exist within said intersection on this rule!\n\n\n            if( localMutations>0 ){\n                let newSquareData = cloneSquare(immutableSquare);\n                newSquareData.candidates = replacementCandidates;\n                \n                mutableBoardData[cellIdx]=newSquareData;\n                mutations += localMutations;\n            }\n\n            \n        });\n         return mutations;\n        \n    }\n     \n\n\n}\nfunction gridClasses(idx){\n    let column = idx%9;\n    let row = (idx-column)/9;\n    return `row-${row} column-${column}`;\n}\nexport default Quadruple;","import React, { useState, useEffect } from 'react';\nimport './App.scss';\nimport Board from './Board'\nimport Standard from \"./rules/standard\";\n\nimport Cage from './rules/cage';\nimport Same from './rules/same';\nimport Kropke from './rules/kropke';\nimport Knight from './rules/knight';\nimport King from './rules/king';\nimport Pawn from './rules/pawn';\nimport Thermometer from './rules/thermometer';\nimport Renban from './rules/renban';\nimport Mod from './rules/mod';\n\nimport LittleKiller from './rules/littleKiller';\nimport Canvas from './Canvas';\nimport Whisper from './rules/whisper';\nimport Palindrome from './rules/palindrome';\nimport Quadruple from './rules/quadruple'\n// snyder notation - puts a mark on the cell if the candidate can ONLY go in 2 cells\n// if we get 2 snyder marks ( i.e 7,9 on 2 squares, those must be eliminated form other cells)\n// Center marks are the only candidates that are possible in a ceell, as opposed to the only cells that are possible for a candidate\n\nfunction Controls(props) {\n\n\n\n  return <div>\n    <button onClick={(e) => props.clickDispatcher(e, 'mode')}> Toggle mode ( {props.mode ? \"Cell\" : \"Candidate\"}) </button>\n    <button onClick={(e) => props.clickDispatcher(e, 'undo')}>Undo</button>\n    <button onClick={(e) => props.clickDispatcher(e, 'redo')}>Redo</button>\n    <button onClick={(e) => props.clickDispatcher(e, 'accept')}>Accept</button>\n    \n    <button onClick={(e) => props.clickDispatcher(e, 'cage', prompt(\"Value\", \"9\"))}>Create Cage</button>\n    <button onClick={(e) => props.clickDispatcher(e, 'thermometer')}>Thermometer</button>\n    <button onClick={(e) => props.clickDispatcher(e, 'renban')}>Renban</button>\n    <button onClick={(e) => props.clickDispatcher(e, 'kropke', prompt(\"Type\", \"1\"))}>Kropke</button>\n    <br ></br>\n    <button onClick={(e) => props.clickDispatcher(e, 'whisper')}>Whisper</button>\n    <button onClick={(e) => props.clickDispatcher(e, 'palindrome')}>Palindrome</button>\n    <button onClick={(e) => props.clickDispatcher(e, 'quadruple', prompt(\"Enter Values\", \"\"))}>Quadruple</button>\n    <button onClick={(e) => props.clickDispatcher(e, 'mod', 2, 1)}>Odd</button>\n    <button onClick={(e) => props.clickDispatcher(e, 'mod', 2, 0)}>Even</button>\n    <button onClick={(e) => props.clickDispatcher(e, 'mod', prompt(\"ModVal\", \"3\"), prompt(\"ModResult\", \"0\"))}>Mod</button>\n    <br />\n    <button onClick={(e) => props.clickDispatcher(e, 'chess', 'knight', prompt(\"Match Distance\", \"0\"))}>Apply Knights Move</button>\n    <button onClick={(e) => props.clickDispatcher(e, 'chess', 'pawn', prompt(\"Match Distance\", \"0\"))}>Apply pawn Move</button>\n    <button onClick={(e) => props.clickDispatcher(e, 'chess', 'king', prompt(\"Match Distance\", \"0\"))}>Apply king Move</button>\n    <button onClick={(e) => props.clickDispatcher(e, 'littleKiller', prompt(\"Value\", \"45\"))}>Create Little Killer Cage</button>\n    <button onClick={(e) => props.clickDispatcher(e, 'color', prompt(\"Value\", \"1\"))}>Color digit</button>\n    <br />\n    <button onClick={(e) => props.clickDispatcher(e, 'same')}>Same</button>\n  </div>\n\n}\n\nfunction cloneSquare(squareData) {\n  let newSquareData = {\n    ...squareData,\n    candidates: [...squareData.candidates],\n  };\n  newSquareData.cloneSquare = () => cloneSquare(newSquareData);\n  return newSquareData;\n\n}\n// I am having troubles with nested items failing to be replaced\n// so I lifted up all the nested parts of the squareData, and now the state will have seperate values for \nfunction startingState() {\n\n  let boardData = [...Array(9 * 9).fill(null)];\n\n  [...Array(9 * 9).fill(null)].forEach((value, index, array) => {\n    let candidates = [...Array(9).keys()].map(k => k + 1);\n    boardData[index] = {\n      cloneSquare: null,\n      given: 0,\n      answer: 0,\n      candidates: candidates,\n      selected: false,\n      color: 0,\n      idx: index,\n      cageValue: null,\n      cageFlags: 0\n    };\n    boardData.cloneSquare = () => { };\n  });\n  let columnRules = Array(9).fill(0).map((a, y) => Standard.fromRectangle(y, 0, 1, 9, boardData));\n  let rowRules = Array(9).fill(0).map((a, x) => Standard.fromRectangle(0, x, 9, 1, boardData));\n  let boxRules = Array(9).fill(0).map((a, b) => {\n    let y = 3 * Math.floor(b / 3);\n    let x = 3 * (b % 3);\n    let r = Standard.fromRectangle(y, x, 3, 3, boardData);\n    return r;\n  });\n\n  let rules = [...columnRules, ...rowRules, ...boxRules];\n  //  let rules = [new Normal(boardData)];\n  return {\n    \"boardData\": boardData,\n    \"rules\": rules,\n    \"index\": 0,\n    \"selection\": [],\n    \"lastAction\": \"\"\n  };\n}\n\n\n\nfunction App() {\n\n  const [mode, setMode] = useState(1);\n  const [count, setCount] = useState(0);\n  const [history, setHistory] = useState(() => [startingState()]);\n  const current = history[count];\n\n  const applyNewRule = (newBoardData, newRule) => {\n    updateBoardHistory(newBoardData, count + 1, `create new`, newRule);\n  }\n  //TODO: gracefully handle selections between actions - reqind or fastforward through them as appropriate - or run a clearselection on them\n  const clickDispatcher = (e, command, ...props) => {\n    let newRule = null;\n    let newBoardData = [...current.boardData];\n    let selectedCells = current.selection.map(i => newBoardData[i]);\n    switch (command) {\n\n      case \"undo\":\n        if (count) { setCount(count - 1); }\n        break;\n      case \"redo\":\n        if (count + 1 < history.length) { setCount(count + 1); }\n        break;\n      case \"accept\":\n        accept();\n        break;\n      case \"mode\":\n        setMode(1 - mode);\n        break;\n      case \"thermometer\":\n        newRule = new Thermometer(selectedCells);\n        break;\n      case \"renban\":\n        newRule = new Renban(selectedCells);\n      break;\n      case \"kropke\":\n        let [type/*, ...p*/] = [...props];\n        newRule = new Kropke(selectedCells, type);\n      break;\n      case \"same\":\n        newRule = new Same(selectedCells);\n        break;\n      case \"mod\":\n        let [modVal, modResult/*, ...p*/] = [...props];\n        newRule = new Mod(selectedCells, modVal, modResult);\n      break;\n      case \"whisper\":\n        newRule = new Whisper(selectedCells);\n        break;\n      case \"quadruple\":\n        {\n          let [value/*, ...p*/] = [...props];\n          newRule = new Quadruple(selectedCells, value);\n        }\n        break;\n\n      case \"palindrome\":\n        newRule = new Palindrome(selectedCells);\n        break;\n      case \"cage\":\n      case \"littleKiller\":\n        {\n          let [value/*, ...p*/] = [...props];\n          //let exact = window.confirm(\"exact?\");\n\n          if (command === \"cage\") {\n            newRule = new Cage(selectedCells, true, value);\n          }\n          if (command === \"littleKiller\") {\n            newRule = new LittleKiller(selectedCells, true, value);\n          }\n        }\n        break;\n      case \"chess\":\n        {\n          let [chessPiece, parameter/*, ...p*/] = [...props];\n          switch (chessPiece) {\n            case \"knight\":\n              newRule = new Knight(newBoardData, parameter);\n              break;\n            case \"king\":\n              newRule = new King(newBoardData, parameter);\n              break;\n            case \"pawn\":\n              newRule = new Pawn(newBoardData, parameter);\n              break;\n            default: break;\n          }\n\n        }\n\n        break;\n      case \"color\":\n        console.log(\"coloring cells\");\n        let [value/*, ...p*/] = [...props];\n\n        newBoardData.forEach((c, i, a) => {\n          let n = cloneSquare(c);\n          let v = parseInt(value);\n          let q = n.candidates.includes(v);\n          console.log(n, v, q)\n\n          n.color = q ? \"blue\" : \"none\";\n          a[i] = n;\n          console.log(\"Change selected\", i, a[i].selected)\n        });\n        updateBoardHistory(newBoardData, count + 1, `highlight`);\n        break;\n\n      default: break;\n\n    }\n    if (newRule) {\n      applyNewRule(newBoardData, newRule);\n    }\n  }\n\n\n\n\n  // change this to accept a response from the apply function, I don't like having apply mutate the board directly\n  const applyRules = (newBoardData, selectedCellIndexes = []) => {\n\n    if (!newBoardData) {\n      newBoardData = [...current.boardData];\n    }\n\n    if (current.lastAction.startsWith(\"select\")) {\n      return;\n    }\n    let mutations = 0;\n    let mutation_count = 0;\n    /* this is th eonly function that needs to do calculations curently, all other functions only manage selection highlighting */\n    // there is a technique we can apply if all instanced of a candidate apply withing a collision of two regions, they cannot be outside of it\n    current.rules.forEach((rule, index, array) => {\n      // returns [.. {idx, candidates} ..]\n      let rule_mutations = rule.apply(newBoardData, cloneSquare);\n\n      if (rule_mutations) {\n        //mutated = true;\n        mutations = mutations + 1;\n        mutation_count = mutation_count + rule_mutations;\n      }\n\n    });\n\n    // When it comes to auto-removing values, I also need to consider just marking them as\n    if (mutations === 0) {\n\n\n      current.rules.forEach((ruleA, indexA, arrayA) => {\n        current.rules.forEach((ruleB, indexB, arrayB) => {\n          if (ruleA === ruleB) {\n            return;\n          }\n          return;\n\n          // {\n          //   if (!(ruleA.supportsIntersectionSource() && ruleB.supportsIntersectionSource())) {\n          //     return;\n          //     // any candidate that only exists in a region, and the places it exists overlap with another region, it must be withing the intersection\n          //   }\n\n\n          //   // I can build a rule inside knight etc, that can conclude - if a candidate being true, makes another region impossible, then it cannot be true - this is a reversal of the way we phrase about an intersction\n          //   // becasue if the candidate is in RuleB, in a location that is not in the intersection, then ruleA becomes impossible.\n\n          //   [...Array(9).fill(0).keys()].forEach((cm, index, arr) => {\n          //     // if all of the values of candidate are in (A int B), remove candidate from all other cells in B;\n          //     let candidate = index + 1;\n\n          //     /*\n          //     if( candidate => ruleB.impossible)\n\n\n          //     */\n\n          //     let locationA = ruleA.cellIndexes.filter((i) => newBoardData[i].candidates.includes(candidate));\n          //     let locationB = ruleB.cellIndexes.filter((i) => newBoardData[i].candidates.includes(candidate));\n\n\n\n\n          //     let intersection = locationA.filter((i) => locationB.includes(i));\n          //     if (intersection.length === 0) {\n          //       return;\n          //     }\n\n          //     //something like knights move does not have a standard intersection, however intersections in the other rule are based on the current candidate square\n\n          //     // Cages for example,  work ruleA-->B in the context -- If a candidate in the Cage would make the other rule impossible, the candidate must be removed\n          //     //      Alternatively, ruleB->A -- If all candidates in ruleB intersect with the cage, then the candidate in ruleB must be valid, and in ruleA are forbidden ( same result )\n          //     // If all candidates in a Normal Rule A exist within the intersection of another Unique Rule B, then all other locations in B must be forbidden\n          //     // If a particular candidate in Unique Rule A exists outside of the intersection with Standard Rule B, and that candidate only exist withing the intersection in rule B, then this candidate must be removed\n\n          //     // For knights moves\n          //     // if a particular candidate in knighs Rule A exists outside the of the intersection with Standard RUle B, and that candidate only exist withing the intersection in rule B, then this candidate must be removed\n          //     // AKA - if a particular cnadidate \"Sees\", all candidates in Standard Rule B, then it mus tbe forbidden.\n          //     // for knights though, this must work a little differnt - it has to look at the knights move, and the x/y intersections\n\n\n\n          //     // so for candidate N in in a square Y of any number of rules; if N \"intersect\" with all instances of N in Rule Z, then candidate N must be removed from square Y\n\n          //     // \n          //     /* \n          //     for ruleZ in rules:\n          //       for squareY in ruleZ:\n          //         for candidateN in square:\n          //           generate intersection of all rules(Square Y / Candidate N)\n          //           if all N in ruleZ are within intersection - N must be removed from  from Y\n\n          //     */\n\n\n          //     if (locationA.every((i) => intersection.includes(i))) {\n          //       // every value of candidate from ruleA is within the intersection.  for normal rules this means that the value must be removed form \n          //       // all cells in ruleB, if B is a 'unique' rule;\n          //       // but not all \n          //       if (locationB.length > intersection.length) {\n          //         //removing it\n          //         ruleB.cellIndexes.forEach((c) => {\n          //           if (!intersection.includes(c)) {\n          //             //mutations = mutations+1;\n\n          //             let newSquareData = cloneSquare(newBoardData[c]);\n          //             console.log(\"Removing value from square becasue of intersection logic\", indexA, indexB, locationA, locationB, intersection);\n          //             newSquareData.candidates = newSquareData.candidates.map((i) => i === candidate ? 0 : i);\n          //             mutations = mutations + 1;\n          //             newBoardData[c] = newSquareData;\n\n          //           }\n          //         });\n          //       }\n          //     }\n\n          //   });\n          // }\n          //applyIntersection(ruleA, ruleB);\n\n          // If a candidate being true, make a region impossible, then the candidate must be forbidden\n        })\n      });\n\n    }\n\n    // todo: rule intersection ( if a candidate only exists in teh colliosion of one rule and another, then it must be within that collision in the other one as well)\n\n    if (mutations) {\n      updateBoardHistory(newBoardData, count, `rules-${count}`);\n    }\n    \n    //remove impossible candidates\n    //identify Solved cells\n  }\n  const keyPressHandler = (event) => {\n\n    //mode = \n    if (false !== event.target.readOnly) {\n      event.preventDefault();\n      let number = parseInt(event.key);\n      if (!isNaN(number)) {\n        updateSelections(number);\n        // type into highlighted squares\n      }else{\n        if( event.key === 's'){\n          clickDispatcher(event, 'same');\n        }\n        if( event.key === 'c'){\n          console.log(event);\n          clickDispatcher(event, 'cage', prompt(\"Value\", \"9\"));\n        }\n      }\n    }\n\n\n\n  }\n  let captureKeys = () => {\n    document.addEventListener(\"keydown\", keyPressHandler);\n    return () => {\n      document.removeEventListener(\"keydown\", keyPressHandler);\n\n    }\n  }\n\n  useEffect(captureKeys);\n  useEffect(() => {\n\n    applyRules(0, []);\n\n    // apply\n    // is it possible to apply rules without saving them to the state.\n\n  });\n\n  const snyderClickHandler = (props, candidate) => (event) => {\n\n  };\n  const select = (props, selectionType, clearFlag) => {\n    /* Clear all selections and set current square to selected */\n\n    let action = `selection-${selectionType}-idx-${props.idx}`;\n\n    // eslint-disable-next-line \n    if (current.lastAction.eq == action) {\n      return;\n    }\n\n\n    updateSelectionHistory(props.idx, action, clearFlag);// Do something so that we update the current record, instead of pushing\n\n  }\n  const squareMouseDownHandler = (props) => (event) => {\n    /* Clear all selections and set current square to selected */\n    let clear = true;\n    event.preventDefault();\n    if (event.ctrlKey) {\n      if (current.boardData[props.idx].selected) {\n        return;\n      }\n      clear = false;\n    }\n    select(props, \"squareMouseDownHandler\", clear);\n\n\n  };\n  const squareClickHandler = (props) => (event) => {\n\n  };\n  const squareDragHandler = (props) => (event) => {\n    /* Update existing state  from mouseDown and add new square selected */\n    event.preventDefault();\n\n    if (!event.buttons) {\n      return;\n    }\n    if (current.boardData[props.idx].selected) {\n      return;\n    }\n\n    select(props, \"squareDragHandler\", false);\n\n\n  }\n\n  const extractClonedSquare = (idx) => {\n    let squareData = current.boardData[idx];\n    return cloneSquare(squareData);\n\n  }\n  const updateBoardHistory = (newBoardData, spot, action, newRule = null, newSelections) => {\n    // If the new Rules have modified newBoardData in thier constructor, this will catch it.\n\n    let selections = [...current.selection];\n    if (newSelections) {\n      selections = newSelections;\n    }\n    let rules = [...current.rules];\n    if (newRule) {\n      rules.push(newRule);\n      newRule.setFlags(newBoardData);\n    }\n\n    setHistory([...history.slice(0, spot), {\n      \"boardData\": newBoardData,\n      \"rules\": rules,\n      \"index\": newBoardData.index,\n      lastAction: action,\n      \"selection\": selections\n    }]);\n    setCount(spot);\n\n  }\n  const updateSelections = (number, selections = null) => {\n\n    // mode = 0: update Candidates\n    // mode = 0; update Answers\n    /* On some updates ( selection reset update ), we want to undo to the previous record, and append a new record based on the current selection */\n    let spot = count + 1;\n    let newBoardData = [...current.boardData];\n    let selectedCellIndexes = [];\n    if (selections) {\n      selectedCellIndexes = selections;\n    } else {\n      selectedCellIndexes = newBoardData.filter((cell) => cell.selected).map((cell) => cell.idx);\n    }\n\n    let mutations = 0;\n    // leave old square data references pointing to existing square data from previous record.  be carefule when updating the \"current record\" to alwatys create a new squaredata value;\n    selectedCellIndexes.forEach((cellIndex, index, array) => {\n\n      let squareData = newBoardData[cellIndex];\n      let newSquareData = cloneSquare(squareData);\n      let mutated = false;\n      if (!newSquareData.given) {\n        if (mode === 0) {\n          if (newSquareData.candidates[number - 1] === number) {\n            mutated = true;\n            newSquareData.candidates[number - 1] = 0;\n          }\n        } else {\n          if (newSquareData.answer !== number) {\n            mutated = true;\n            newSquareData.answer = number;\n          }\n        }\n\n        if (mutated) {\n          mutations = mutations + 1;\n          newBoardData[cellIndex] = newSquareData;\n        }\n      }\n\n    });\n\n    if (mutations > 0) {\n\n      //applyRules(newBoardData, selectedCellIndexes);\n      updateBoardHistory(newBoardData, spot, `set-value-${number}`);\n    }\n  }\n  const accept = () => {\n    // set answers to thier only accepted values\n\n\n    // mode = 0: update Candidates\n    // mode = 0; update Answers\n    /* On some updates ( selection reset update ), we want to undo to the previous record, and append a new record based on the current selection */\n    let spot = count + 1;\n    let newBoardData = [...current.boardData];\n\n\n    let acceptedCells = newBoardData.filter((cell) => cell.candidates.filter(c => c !== 0).length === 1);\n\n    let mutations = 0;\n    // leave old square data references pointing to existing square data from previous record.  be carefule when updating the \"current record\" to alwatys create a new squaredata value;\n    acceptedCells.forEach((cell, index, array) => {\n      if (cell.given || cell.answer) {\n        return;\n      }\n      let newSquareData = cloneSquare(cell);\n      //let mutated = false;\n      let answer = cell.candidates.find((c) => c !== 0);\n      newSquareData.answer = answer;\n      newBoardData[cell.idx] = newSquareData;\n      mutations = mutations + 1;\n\n    });\n\n    if (mutations > 0) {\n      updateBoardHistory(newBoardData, spot, `accept`);\n    }\n  }\n  const updateSelectionHistory = (idx, action, clearFlag) => {\n\n\n    // on click, take current board, clear all selections, and add my own selection, replace current board ( or add to current board if last action was not select)\n    // on drag, take current board,                           add my own selection, replace current board( or add to current board if last action was not select)\n\n    /* On some updates ( selection reset update ), we want to undo to the previous record, and append a new record based on the current selection */\n    let spot = count + 1;\n    if (current.lastAction.startsWith(\"selection-\")) {\n      spot = count;\n    }\n    let newBoardData = [...current.boardData]; // equal to current unless we change spot from  count+1 to count;\n    // if click - clear all the selections\n\n    let selections = [...current.selection];\n    if (clearFlag) {\n      newBoardData.forEach((squareData, index, array) => {\n        if (squareData.selected) {\n          let newSquareData = extractClonedSquare(index,);\n          newSquareData.selected = false;\n          array[index] = newSquareData;\n        }\n      });\n      selections = [];\n    }\n\n    // leave old square data references pointing to existing square data from previous record.  be carefule when updating the \"current record\" to alwatys create a new squaredata value;\n    let newSquareData = extractClonedSquare(idx);\n    newSquareData.selected = true;\n    newBoardData[idx] = newSquareData;\n    updateBoardHistory(newBoardData, spot, action, null, [...selections, idx]);\n\n  }\n  return (\n    <div onKeyDown={keyPressHandler}>\n      <p>You clicked {count} times</p>\n      <button onClick={() => {\n        setCount(0);\n      }}>\n        Reset\n      </button>\n      <br />\n      <input type=\"text\" name=\"importString\" id=\"inputString\" />\n      <button onClick={() => {\n        /* On some updates ( selection reset update ), we want to undo to the previous record, and append a new record based on the current selection */\n        let newBoardData = [...current.boardData];\n        let [givens, answers] = document.getElementById(\"inputString\").value.split('/');\n        let givenValues = givens.split('');\n        let answerValues = (answers || \"\").split('');\n        // leave old square data references pointing to existing square data from previous record.  be carefule when updating the \"current record\" to alwatys create a new squaredata value;\n        givenValues.forEach((value, index, array) => {\n          if (index < 9 * 9) {\n            let number = parseInt(value);\n            if (!isNaN(number) && number > 0) {\n              let newSquareData = extractClonedSquare(index);\n              newSquareData.given = number;\n              newBoardData[index] = newSquareData;\n            }\n          }\n        });\n        answerValues.forEach((value, index, array) => {\n          if (index < 9 * 9) {\n            let number = parseInt(value);\n            if (!isNaN(number) && number > 0) {\n              let newSquareData = extractClonedSquare(index);\n              newSquareData.answer = number;\n              newBoardData[index] = newSquareData;\n            }\n          }\n        });\n\n\n        //applyRules(newBoardData, selectedCellIndexes);\n        if (givenValues.length + answerValues.length > 0) {\n          updateBoardHistory(newBoardData, count + 1, `set-value-input`);\n        }\n\n      }}>\n        Import\n      </button>\n      <button onClick={() => {\n        let givenValues = current.boardData.map((cellData) => cellData.given);\n        let answerValues = current.boardData.map((cellData) => cellData.answer);\n        let exportString = givenValues.join('') + '/' + answerValues.join('');\n        document.getElementById(\"exportString\").value = exportString;\n      }} >Export</button>\n\n      <br />\n      <input type=\"text\" name=\"exportString\" id=\"exportString\" />\n      <br />\n\n      <Controls clickDispatcher={clickDispatcher.bind(this)} mode={mode} />\n      <Canvas>\n        <Board boardData={current.boardData} rules={current.rules} onMouseDown={squareMouseDownHandler} onClick={squareClickHandler} snyderClickHandler={snyderClickHandler} squareDragHandler={squareDragHandler} />\n      </Canvas>\n    </div>\n\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}